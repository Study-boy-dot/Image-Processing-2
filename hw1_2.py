# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'GUI.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from random import gauss
from PyQt5 import QtCore, QtGui, QtWidgets
import math
from pickletools import uint8
from PyQt5.QtWidgets import QFileDialog
from cv2 import blur, waitKey
import numpy as np
import cv2

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.loadBtn = QtWidgets.QPushButton(self.centralwidget)
        self.loadBtn.setGeometry(QtCore.QRect(30, 200, 141, 41))
        self.loadBtn.setObjectName("loadBtn")
        self.groupBox = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox.setGeometry(QtCore.QRect(220, 80, 231, 371))
        self.groupBox.setAutoFillBackground(False)
        self.groupBox.setCheckable(False)
        self.groupBox.setObjectName("groupBox")
        self.gbBtn = QtWidgets.QPushButton(self.groupBox)
        self.gbBtn.setGeometry(QtCore.QRect(20, 40, 191, 41))
        self.gbBtn.setObjectName("gbBtn")
        self.sobelxBtn = QtWidgets.QPushButton(self.groupBox)
        self.sobelxBtn.setGeometry(QtCore.QRect(20, 120, 191, 41))
        self.sobelxBtn.setObjectName("sobelxBtn")
        self.sobelyBtn = QtWidgets.QPushButton(self.groupBox)
        self.sobelyBtn.setGeometry(QtCore.QRect(20, 200, 191, 41))
        self.sobelyBtn.setObjectName("sobelyBtn")
        self.magBtn = QtWidgets.QPushButton(self.groupBox)
        self.magBtn.setGeometry(QtCore.QRect(20, 270, 191, 41))
        self.magBtn.setObjectName("magBtn")
        self.groupBox_2 = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_2.setGeometry(QtCore.QRect(480, 80, 231, 371))
        self.groupBox_2.setAutoFillBackground(False)
        self.groupBox_2.setCheckable(False)
        self.groupBox_2.setObjectName("groupBox_2")
        self.resizeBtn = QtWidgets.QPushButton(self.groupBox_2)
        self.resizeBtn.setGeometry(QtCore.QRect(20, 40, 191, 41))
        self.resizeBtn.setObjectName("resizeBtn")
        self.transBtn = QtWidgets.QPushButton(self.groupBox_2)
        self.transBtn.setGeometry(QtCore.QRect(20, 120, 191, 41))
        self.transBtn.setObjectName("transBtn")
        self.rotateBtn = QtWidgets.QPushButton(self.groupBox_2)
        self.rotateBtn.setGeometry(QtCore.QRect(20, 200, 191, 41))
        self.rotateBtn.setObjectName("rotateBtn")
        self.shearingBtn = QtWidgets.QPushButton(self.groupBox_2)
        self.shearingBtn.setGeometry(QtCore.QRect(20, 270, 191, 41))
        self.shearingBtn.setObjectName("shearingBtn")
        self.fileNameLbl = QtWidgets.QLabel(self.centralwidget)
        self.fileNameLbl.setGeometry(QtCore.QRect(30, 260, 141, 31))
        self.fileNameLbl.setText("")
        self.fileNameLbl.setObjectName("fileNameLbl")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        # Load image button
        self.loadBtn.clicked.connect(self.loadImg)

        # Homework 1-3
        self.gbBtn.clicked.connect(self.GaussianBlur)
        self.sobelxBtn.clicked.connect(self.SobelX)
        self.sobelyBtn.clicked.connect(self.SobelY)
        self.magBtn.clicked.connect(self.Magnitude)

        # Homework 1-4
        self.resizeBtn.clicked.connect(self.Resize)
        self.transBtn.clicked.connect(self.Translation)
        self.rotateBtn.clicked.connect(self.Rotate)
        self.shearingBtn.clicked.connect(self.Shearing)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.loadBtn.setText(_translate("MainWindow", "Load Image"))
        self.groupBox.setTitle(_translate("MainWindow", "3.Edge Detection"))
        self.gbBtn.setText(_translate("MainWindow", "3.1 Gaussian Blur"))
        self.sobelxBtn.setText(_translate("MainWindow", "3.2 Sobel X"))
        self.sobelyBtn.setText(_translate("MainWindow", "3.3 Sobel Y"))
        self.magBtn.setText(_translate("MainWindow", "3.4 Magnitude"))
        self.groupBox_2.setTitle(_translate("MainWindow", "4.Transformation"))
        self.resizeBtn.setText(_translate("MainWindow", "4.1 Resize"))
        self.transBtn.setText(_translate("MainWindow", "4.2 Translation"))
        self.rotateBtn.setText(_translate("MainWindow", "4.3 Rotation, Scaling"))
        self.shearingBtn.setText(_translate("MainWindow", "4.4 Shearing"))

    def loadImg(self):
        fname = QFileDialog.getOpenFileName(caption='Open File', directory='./')
        ImgPath = fname[0]
        txt = fname[0].split("/")
        self.fileNameLbl.setText(txt[-1])
        self.image = cv2.imread(ImgPath)
        if(self.image is None):
            print('load image failed\n')
            return
        print(self.image.shape)

    def GaussianBlur(self):
        gaussianFilter = self.gkern()

        # Color transformation to grayscale
        if(self.image is None):
            print('load image failed\n')
            return

        grayImage = cv2.cvtColor(self.image, cv2.COLOR_BGR2GRAY)
        cv2.imshow("Grayscale Image", grayImage)
        bluredImage = self.convolve2d(grayImage, gaussianFilter)
        cv2.imshow("Blured Image", bluredImage)
        
    def gkern(size = 3, sigma = 0.5):
        """  method on website
        #3*3 Gassian filter
        x, y = np.mgrid[-1:2, -1:2]
        gaussian_kernel = np.exp(-(x**2+y**2))

        #Normalization
        gaussian_kernel = gaussian_kernel / gaussian_kernel.sum()
        """
        sigma = math.sqrt(0.5)
        x = -1
        y = -1
        indexX = 0
        indexY = 0

        # Init
        gaussianFilter = np.zeros((3,3),dtype=np.float64)

        # Calculate
        while y < 2:
            x = -1
            indexX = 0
            while x < 2:
                gaussianFilter[indexY][indexX] = math.exp(-(x**2 + y**2)/(2*sigma**2))/(2*math.pi*sigma**2)
                x += 1
                indexX += 1
            y += 1
            indexY += 1

        # Normalize
        gaussianFilter = np.divide(gaussianFilter, gaussianFilter.sum())
        gaussianFilter = np.around(gaussianFilter, decimals=3)
        return gaussianFilter

    def convolve2d(self, image, kernel):
        height = image.shape[0]
        width = image.shape[1]
        bluredImg = np.zeros((height-1, width-1))
        for y in range(height):
            if y + kernel.shape[0] > height:
                break
            for x in range(width):
                if x + kernel.shape[1] > width:
                    break

                bluredImg[y,x] = np.abs((kernel * image[y:y+kernel.shape[0], x:x+kernel.shape[1]]).sum())
                if bluredImg[y,x] > 255:
                    bluredImg[y,x] = 255
                    

        return bluredImg.astype(np.uint8)

    def SobelX(self):
        """ Get gaussian blur image """
        gaussianFilter = self.gkern()

        # Color transformation to grayscale
        if(self.image is None):
            print('load image failed\n')
            return

        grayImage = cv2.cvtColor(self.image, cv2.COLOR_BGR2GRAY)
        bluredImage = self.convolve2d(grayImage, gaussianFilter)


        # Init sobelx matrix
        sobelxFilter = np.array([[-1,0,1],[-2,0,2],[-1,0,1]])
        sobelxImage = self.convolve2d(bluredImage, sobelxFilter)
        sobelxImage = sobelxImage.astype(np.uint8)
        # sobelxImage = abs(sobelxImage)
        # sobelxImage[sobelxImage > 255] = 255
        # print(sobelxImage.max())
        # Threshold
        sobelxImage = self.Threshold(sobelxImage, 100, 255, 1)
        cv2.imshow("Sobel X image", sobelxImage)
        return sobelxImage

    def SobelY(self):
        """ Get gaussian blur image """
        gaussianFilter = self.gkern()

        # Color transformation to grayscale
        if(self.image is None):
            print('load image failed\n')
            return

        grayImage = cv2.cvtColor(self.image, cv2.COLOR_BGR2GRAY)
        bluredImage = self.convolve2d(grayImage, gaussianFilter)


        # Init sobelx matrix
        sobelyFilter = np.array([[1,2,1],[0,0,0],[-1,-2,-1]])
        sobelyImage = self.convolve2d(bluredImage, sobelyFilter)
        sobelyImage = sobelyImage.astype(np.uint8)
        # sobelyImage = abs(sobelyImage)

        # Threshold
        sobelyImage = self.Threshold(sobelyImage, 100, 255, 1)
        cv2.imshow("Sobel Y image", sobelyImage)
        return sobelyImage

    def Threshold(self, image, lower, upper, multiply):
        # output = np.zeros(image.shape[0:2], dtype=np.uint8)
        output = np.where((image >= lower) & (image <= upper), image,0)
        # for i in range(image.shape[0]):
        #     for j in range(image.shape[1]):
        #         if image[i,j] >= lower and image[i,j] <= upper:
        #             output[i,j] = image[i,j]
        #         else:
        #             output[i,j] = 0

        return output.astype(np.uint8)
                    
    def Magnitude(self):
        sobelx = self.SobelX()
        sobely = self.SobelY()

        output = np.zeros(sobelx.shape[0:2])
        output = np.sqrt(np.square(sobelx) + np.square(sobely))
        # Normalization
        output *= 255 / output.max()
        output = output.astype(np.uint8)
        cv2.imshow("Magnitude", output)

    def Resize(self):
        # resizeImage = cv2.resize(self.image, (215, 215), interpolation=cv2.INTER_AREA)
        # resizeImage = np.hstack((resizeImage,np.zeros(resizeImage.shape[:3])))
        # resizeImage = np.vstack((resizeImage, np.zeros(resizeImage.shape[:3])))
        # resizeImage = resizeImage.astype(np.uint8)
        newPos = np.float32([[0.5,0,0],[0,0.5,0]])
        resizeImage = cv2.warpAffine(self.image, newPos, (430,430))
        cv2.imshow("Resize Image", resizeImage)

    def Translation(self):
        # temp = np.copy(resizeImage)
        # resizeImage = np.hstack((resizeImage,np.zeros(resizeImage.shape[:3])))
        # temp = np.hstack((np.zeros(temp.shape[:3]), temp))
        # resizeImage = np.vstack((resizeImage, temp))
        # resizeImage = resizeImage.astype(np.uint8)
        
        newPos = np.float32([[0.5,0,0],[0,0.5,0]])
        resizeImage = cv2.warpAffine(self.image, newPos, (430,430))
        newPos = np.float32([[0.5,0,215],[0,0.5,215]])
        transImage = cv2.warpAffine(self.image, newPos, (430,430))
        outputImage = cv2.addWeighted(resizeImage, 1, transImage, 1, 3)
        # print(transImage.shape)
        # transImage = cv2.resize(transImage, (215, 215), interpolation=cv2.INTER_AREA)
        # cv2.namedWindow("Translate Image",cv2.WINDOW_KEEPRATIO)
        # cv2.resizeWindow("Translate Image", 430, 430)
        cv2.imshow("Translate Image", outputImage)

    def Rotate(self):
        newPos = np.float32([[1,0,0],[0,1,0]])
        smallImage = cv2.resize(self.image, (215, 215), interpolation=cv2.INTER_AREA)
        resizeImage = cv2.warpAffine(smallImage, newPos, (430,430))
        newPos = np.float32([[1,0,215],[0,1,215]])
        transImage = cv2.warpAffine(smallImage, newPos, (430,430))
        outputImage = cv2.addWeighted(resizeImage, 1, transImage, 1, 3)

        # newPos = np.float32([[0.5,0,107],[0,0.5,107]])
        # outputImage = cv2.warpAffine(outputImage, newPos, (430,430))
        M = cv2.getRotationMatrix2D((215, 215), 45, 0.5)    # 中心點 (240, 180)，旋轉 45 度，尺寸 1
        outputImage = cv2.warpAffine(outputImage, M, (430, 430))

        cv2.imshow('Rotate Image', outputImage)

    def Shearing(self):
        newPos = np.float32([[1,0,0],[0,1,0]])
        smallImage = cv2.resize(self.image, (215, 215), interpolation=cv2.INTER_AREA)
        resizeImage = cv2.warpAffine(smallImage, newPos, (430,430))
        newPos = np.float32([[1,0,215],[0,1,215]])
        transImage = cv2.warpAffine(smallImage, newPos, (430,430))
        outputImage = cv2.addWeighted(resizeImage, 1, transImage, 1, 3)

        # newPos = np.float32([[0.5,0,107],[0,0.5,107]])
        # outputImage = cv2.warpAffine(outputImage, newPos, (430,430))
        M = cv2.getRotationMatrix2D((215, 215), 45, 0.5)    # 中心點 (240, 180)，旋轉 45 度，尺寸 1
        outputImage = cv2.warpAffine(outputImage, M, (430, 430))

        theta = 30
        fai = 60
        # pts1 = np.float32([[220,215],[215,220],[210,215]])
        # pts2 = np.float32([[215+5*np.cos(theta),0],[215,220],[215-5*np.cos(theta),215]])
        # M_shear = cv2.getAffineTransform(pts1,pts2)
        # print(M_shear)
        M_shear = self.shearKern((theta, fai), (215,215))    
        # M_shear = np.float32([[np.cos(theta), 0, 0],[0 ,1,0]])
        shearImage = cv2.warpAffine(outputImage, M_shear, (430, 430))
        cv2.imshow("Sheared Image", shearImage)

    def shearKern(self, angle, center):
        theta = angle[0]    # rotate in axis y
        fai = angle[1]      # rotate in axis x

        theta = theta * np.pi / 180
        fai = fai * np.pi / 180

        centerx = center[0]
        centery = center[1]

        M_shear = np.float32([[np.cos(theta), 0, -centerx*np.cos(theta)+centerx],[0,np.cos(fai),-centery*np.cos(fai)+centery]]) # 坐标转换，再转回来 UVU^-1

        return M_shear

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())